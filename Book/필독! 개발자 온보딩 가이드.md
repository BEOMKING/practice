> 해당 글은 [필독! 온보딩 가이드](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=317252868)을 나중에 다시 보고 싶은 내용을 개인의 경험과 함께 정리한 글입니다.

## 4장 운영 환경을 고려한 코드 작성

운영 환경을 위한 코드란 보호 장치, 분석 장치, 제어 장치가 내장된 코드를 의미한다. 

안전하고 회복성(resilient)있는 코딩, 방어적(defensive) 프로그래밍을 통해 시스템을 보호해야 한다.

> 현재 B2B에서 근무하고 있는 상황에서 운영 환경을 고려한 코드 작성의 필요성을 느낀다.
>
> B2B SaaS가 아니기 때문에 고객사 운영 환경을 모니터링을 할 수 없기 때문에 장애 발생에 즉각적으로 대처할 수 없다.
>
> 그래서 문제가 생기면 나중에 CS로 들어오는데 이를 최소화하기 위해서라도 필요한 기법이다.

### 장애에 대비하기 위한 방어적 프로그래밍 방안

#### null 값 사용은 피하자

null 체크는 메소드의 시작 시점에서 나머지 코드에서 안전하게 사용할 수 있으므로 좋다.

null 체크를 위해 `Null Object Pattern`, `@NotNull 애노테이션`, `Optional` 등을 활용하자.

#### 불변 변수를 사용하자

의도치 않게 값이 변하면 이를 디버깅하기 쉽지 않다. 불변 변수(자바의 final)를 사용하면 추후 이 변수에는 값이 재할당되지 않는다라는 것을 알고 개발할 수 있다. IDE의 기능 같은 것을 활용하자.

#### 입력값을 검사하자

입력은 클라이언트 화면에서만 온다는 보장이 없다. 악의적인 API 콜이 올 수도 있다. 이를 항상 검사하여 데이터의 훼손을 막자.

꼭 데이터 Validation뿐만이 아니라 SQL Injection, 크로스 사이트 스크립팅 등의 보안도 중요하다.

### 문제 원인을 찾기 위한 로깅 방안

#### 로그 레벨을 사용하자

- TRACE

  특정 패키지나 클래스에서만 켜지며 최대한 상세한 내용을 출력하는 레벨이다. 

  개발 환경 이외에서 사용하는 경우는 거의 없다. TRACE 로그를 자주 사용하는 편이라면 디버거를 통해 코드 실행 과정을 확인하는 편이 낫다.

- DEBUG

  프로덕션 상황에서 문제가 발생했을 때 적합한 레벨이다. 디버그 레벨을 너무 많이 사용하면 디버깅할 때 필요한 정보를 찾기 어렵다. 그럴 때 TRACE를 사용한다.

- INFO

  애플리케이션 상태에 대해 알아두면 좋을 만한 정보를 위한 레벨이다. 

  즉, 문제점을 파악하기 위한 용도가 아니다. INFO는 기본 로그 레벨이므로 시시한 내용을 기록하지 말자.

  INFO 로그는 정상적인 운영 상황에서 유용한 정보를 제공해야 한다.

- WARN

  잠재적으로 문제가 될 만한 상황에 대한 메시지를 출력하기 위한 레벨이다. WARN 레벨 로그를 출력할 때는 메시지를 확인한 사람이 대책이 있어야 하며 만약 없다면 INFO 레벨이 적합하다.

- FATAL

  가장 위험한 수준의 레벨이다. 프로그램에 심각한 상황이 발생하여 당장 종료되어야 한다면 그 원인을 FATAL 로그에 기록하자.

#### 로그는 신속하게 기록하자

로그를 너무 많이 기록하면 성능에 영향을 미친다. 로그를 신속하게 기록하려면 파라미터화(parameterized) 로깅과 비동기 어펜더(appender)를 활용하자.

문자열 결합(string concatenation) 작업은 매우 느리고 성능에 악영향을 미친다.

다음은 자바에서 로그를 호출할 때 문자열을 결합하는 세 가지 방법이다.

```java
while(message.size() > 0) {
	Message m = message.poll();
	// 아래 두 방법은 trace 레벨이 비활성화 되어있어도 결합을 실행한다.
	log.trace("got message: " + m);
	log.trace("got message: {}".format(m));
	
	// 파라미터 로깅은 trace 레벨이 활성화된 경우에만 결합을 실행한다.
	log.trace("got message: {}", m);
}
```

어펜더를 이용해서도 성능에 대한 영향을 관리할 수 있다. 어펜더는 콘솔이나 파일, 원격 로그 수집기 등 다양한 곳으로 로그를 전달한다.

비동기 어펜더는 현재 실행 중인 스레드를 블록하지 않고 로그 메시지를 기록하여 성능을 향상시킬 수 있다. 배치 어펜더는 디스크에 기록하기 전에 메모리에 보관하고 일괄적으로 처리하므로 성능을 향상시킬 수 있으나 두 방법 모두 애플리케이션 크래시가 발생하면 로그 메시지가 기록되지 않는 일도 생길 수 있다.

#### 민감한 데이터는 로그에 기록하지 말자

로그 메시지에는 비밀번호, 토큰, 신용카드 번호, 이메일 주소 같은 개인정보가 포함돼서는 안된다.

당연하지만 매우 중요한 내용이다.

### 애플리케이션 동작 측정을 위한 지표 활용 방안

지표는 크게 `카운터`, `게이지`, `히스토그램`으로 나뉜다.

- 카운터

  특정 이벤트가 발생된 횟수이다. 캐시 히트 카운터와 요청 카운터를 이용하면 캐시를 활용하는 비율을 계산할 수 있다. 값이 단순 증가한다.

- 게이지

  특정 시점을 기준으로 측정하므로 값이 올라가거나 내려갈 수 있다. 게이지는 큐나 스택, 맵의 크기 같은 통곗값을 제시해준다.

- 히스토그램

  규모에 따라 이벤트를 특정 범위로 구분한다. 주로 요청 처리에 걸린 시간이나 데이터 페이로드 크기 같은 지표를 측정한다.

#### 모든 것을 측정하자

- 리소스 풀

  게이지를 이용해 측정한다. 스레드 풀과 커넥션 풀에는 더 신경써야 한다.

- 캐시

  캐시 히트(cache hit)와 캐시 미스(cache miss)도 카운터하자. 두 비율이 바뀐다면 애플리케이션 성능에 영향을 미치는 것이다.

- 데이터 구조

  게이지를 이용해 측정한다. 데이터 구조의 크기가 비정상적으로 커진다는 것은 이상한 일이 발생하는 것이다.

- CPU 집약적 작업

  작업에 걸린 시간을 측정하자. 데이터 직렬화 작업은 상당히 큰 비용이 드므로 더 주의하자.

- IO 집약적 작업

  디스크와 네트워크 I/O 작업은 느리며 예측이 어렵다. 타이머를 이용해 측정해보자.

- 예외와 에러

  예외, 에러 응답 코드, 잘못된 입력은 모두 카운트하자. 에러를 측정하면 쉽게 알람을 발송할 수 있다.

- 원격 요청 및 응답

  모든 요청을 측정한다. 요청 수가 비정상적으로 높거나 낮으면 뭔가 잘못되고 있는 것이다.

  요청에 대한 레이턴시도 측정해야 한다. 시스템이 언제 느려지는지 시점을 파악하자.

