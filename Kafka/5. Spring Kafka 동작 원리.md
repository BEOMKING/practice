카프카 컨슈머는 아래와 같이 구성되었다.

```java
@EnableKafka
@EnableConfigurationProperties(KafkaProperties.class)
@Configuration
@ConditionalOnProperty(name = "spring.kafka.consumer.enabled", havingValue = "true")
public class KafkaConsumerConfig {
    private final KafkaProperties kafkaProperties;

    public KafkaConsumerConfig(final KafkaProperties kafkaProperties) {
        this.kafkaProperties = kafkaProperties;
    }

    @Bean
    public KafkaListenerContainerFactory<ConcurrentMessageListenerContainer<String, Chat>> kafkaListenerContainerFactory() {
        final ConcurrentKafkaListenerContainerFactory<String, Chat> factory = new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory());
        factory.setBatchListener(true);
        factory.getContainerProperties().setAckMode(ContainerProperties.AckMode.MANUAL);

        return factory;
    }

    @Bean
    public ConsumerFactory<String, Chat> consumerFactory() {
        return new DefaultKafkaConsumerFactory<>(consumerConfig(), new StringDeserializer(), new JsonDeserializer<>(Chat.class));
    }

    @Bean
    public Map<String, Object> consumerConfig() {
        return Map.of(
                ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaProperties.getBootstrapServers(),
                ConsumerConfig.GROUP_ID_CONFIG, "chatGroupId",
                ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 200,
                ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "latest",
                ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false
        );
    }

}
```

```java
@Slf4j
@Service
public class ChatConsumer {
    private final ChatRepository chatRepository;

    public ChatConsumer(final ChatRepository chatRepository) {
        this.chatRepository = chatRepository;
    }

    @KafkaListener(id = "chatListener1", topics = "#{'${spring.kafka.topics.chat}'.split(',')}", containerFactory = "kafkaListenerContainerFactory", autoStartup = "${spring.kafka.consumer.enabled}")
    public void recordChat(final List<Chat> chat, final Acknowledgment ack) {
        log.info("Consumed size : {}", chat.size());
        chat.forEach(chatRepository::save);
        ack.acknowledge();
    }
}
```

## 내부 동작
이 코드들이 내부적으로 어떻게 동작하는지 하향식으로 살펴본다.

### `MessageListenerContainer`

Spring에서 Kafka 메시지를 읽어오기 위해서는 Listener가 필요하다. `ConcurrentMessageListenerContainer` 클래스가 이 역할을 수행한다.

`MessageListenerContainer`는 `KafkaMessageListenerContainer`, `ConcurrentMessageListenerContainer` 두 가지 구현체를 제공한다.

- `KafkaMessageListenerContainer` 클래스
    - `KafkaConsumer`를 이용하여 Single-Thread 형태로 메시지를 읽어오는 방식
    - while (true)를 수행하면서 consumer.poll()을 통해 메시지를 읽어온다.

- `ConcurrentMessageListenerContainer` 클래스
    - Concurrency와 실제 Partition의 수에 따라 `KafaMessageListenerContainer`를 N개 생성한다.

```java
public class ConcurrentMessageListenerContainer<K, V> extends AbstractMessageListenerContainer<K, V> {
    private final List<KafkaMessageListenerContainer<K, V>> containers = new ArrayList<>();
    // 생략
```

따라서 여러 개의 Partition을 처리하기 위해서는 `ConcurrentMessageListenerContainer`를 사용하는 것이 더 낫다.

이런 ListenerContainer를 사용하는 것이 `KafkaConsumer`를 직접 사용하는 것보다 풍부한 Ack 모드 지원, 메뉴얼 토픽 파티션 어사인, 오프셋 점프, 손쉬운 스레드 세이프 관리 등의 장점이 있다.

### `MessageListener`

`MessageListener`는 크게 2가지로 나뉜다.

배치 메시지를 처리하는 `BatchMessageListener`와 단일 메시지를 처리하는 `MessageListener`가 있다.

```java
@FunctionalInterface
public interface BatchMessageListener<K, V> extends GenericMessageListener<List<ConsumerRecord<K, V>>> {
    // 생략
}
```

```java
@FunctionalInterface
public interface MessageListener<K, V> extends GenericMessageListener<ConsumerRecord<K, V>> {

}
```

특히 `BatchMessageListener`는 `poll()`을 통해 가져온 데이터를 한 번에 처리하기 때문에 여러번 호출할 필요가 줄어든다.

`BatchMessageListener`를 사용하는 부분이 아래 부분이다. 

```java
// 어노테이션 생략
public class KafkaConsumerConfig {
  // 생략
  @Bean
  public KafkaListenerContainerFactory<ConcurrentMessageListenerContainer<String, Chat>> kafkaListenerContainerFactory() {
    final ConcurrentKafkaListenerContainerFactory<String, Chat> factory = new ConcurrentKafkaListenerContainerFactory<>();
    factory.setConsumerFactory(consumerFactory());
    factory.setBatchListener(true); // 여기
    factory.getContainerProperties().setAckMode(ContainerProperties.AckMode.MANUAL);

    return factory;
  }
  // 생략
}
```

위 설정을 하면 `AbstractMessageListenerContainerFactory`의 `createListenerContainer` 메소드를 호출한다.

```java
public abstract class AbstractKafkaListenerContainerFactory<C extends AbstractMessageListenerContainer<K, V>, K, V>
		implements KafkaListenerContainerFactory<C>, ApplicationEventPublisherAware, InitializingBean,
{
  @Override
  public C createListenerContainer(KafkaListenerEndpoint endpoint) {
    C instance = createContainerInstance(endpoint);
    JavaUtils.INSTANCE
            .acceptIfNotNull(endpoint.getId(), instance::setBeanName)
            .acceptIfNotNull(endpoint.getMainListenerId(), instance::setMainListenerId);
    if (endpoint instanceof AbstractKafkaListenerEndpoint) {
      configureEndpoint((AbstractKafkaListenerEndpoint<K, V>) endpoint);
    }

    if (Boolean.TRUE.equals(endpoint.getBatchListener())) {
      endpoint.setupListenerContainer(instance, this.batchMessageConverter);
    }
    else {
      endpoint.setupListenerContainer(instance, this.recordMessageConverter);
    }
    initializeContainer(instance, endpoint);
    customizeContainer(instance);
    return instance;
  }
}
```

`KafkaListenerEndpoint` 클래스의 `setupMessageListener` 메소드를 호출하며 `BatchMessageListenerAdapter`를 생성한다.

```java
public abstract class AbstractKafkaListenerEndpoint<K, V>
		implements KafkaListenerEndpoint, BeanFactoryAware, InitializingBean 
{
    // 생략
    private void setupMessageListener(MessageListenerContainer container,
                                      @Nullable MessageConverter messageConverter) {

      MessagingMessageListenerAdapter<K, V> adapter = createMessageListener(container, messageConverter);
      JavaUtils.INSTANCE
              .acceptIfNotNull(this.replyHeadersConfigurer, adapter::setReplyHeadersConfigurer)
              .acceptIfNotNull(this.correlationHeaderName, adapter::setCorrelationHeaderName);
      adapter.setSplitIterables(this.splitIterables);
      Object messageListener = adapter;
      boolean isBatchListener = isBatchListener();
      Assert.state(messageListener != null,
              () -> "Endpoint [" + this + "] must provide a non null message listener");
      if (this.recordFilterStrategy != null) {
        if (isBatchListener) {
          if (((MessagingMessageListenerAdapter<K, V>) messageListener).isConsumerRecords()) {
            this.logger.warn(() -> "Filter strategy ignored when consuming 'ConsumerRecords' instead of a List"
                    + (this.id != null ? " id: " + this.id : ""));
          }
          else {
            messageListener = new FilteringBatchMessageListenerAdapter<>(
                    (BatchMessageListener<K, V>) messageListener, this.recordFilterStrategy, this.ackDiscarded);
          }
        }
        else {
          messageListener = new FilteringMessageListenerAdapter<>((MessageListener<K, V>) messageListener,
                  this.recordFilterStrategy, this.ackDiscarded);
        }
      }
      container.setupMessageListener(messageListener);
    }
}
```

`poll()`을 통해 가져온 데이터가 있을 때 `BatchMessageListenerAdapter` 내의 `BatchMessagingMessageConverter` 클래스의 `toMessagingMessage` 메소드를 호출한다.

```java
public class BatchMessagingMessageConverter implements BatchMessageConverter {
  @Override // NOSONAR
  public Message<?> toMessage(List<ConsumerRecord<?, ?>> records, @Nullable Acknowledgment acknowledgment,
                              Consumer<?, ?> consumer, Type type) {

    KafkaMessageHeaders kafkaMessageHeaders = new KafkaMessageHeaders(this.generateMessageId,
            this.generateTimestamp);
    
    // 생략
    
    for (ConsumerRecord<?, ?> record : records) {
      payloads.add(obtainPayload(type, record, conversionFailures));
      keys.add(record.key());
      topics.add(record.topic());
      partitions.add(record.partition());
      offsets.add(record.offset());
      if (record.timestampType() != null) {
        timestampTypes.add(record.timestampType().name());
      }
      timestamps.add(record.timestamp());
      if (this.headerMapper != null && record.headers() != null) {
        Map<String, Object> converted = new HashMap<>();
        this.headerMapper.toHeaders(record.headers(), converted);
        convertedHeaders.add(converted);
        Object object = converted.get(KafkaHeaders.LISTENER_INFO);
        if (object instanceof String) {
          info = (String) object;
        }
      }
      // 생략
    return MessageBuilder.createMessage(payloads, kafkaMessageHeaders);
  }
}
```

### `@KafkaListener`
위에서 언급한 `ConcurrentMessageListenerContainer`를 사용하기 위해서는 `@KafkaListener` 어노테이션을 사용해야 한다.

토픽의 메시지를 소비할 메소드에 어노테이션을 붙이면 `KafkaListenerContainerFactory`를 통해 `ConcurrentMessageListenerContainer`를 생성하고 `KafkaListenerEndpointRegistry`에 등록된다.

메소드에 `@KafkaListener` 어노테이션을 붙이면 각 메소드별로 `MessageListenerContainer`가 생성된다.

클래스에 정의된다면 하나의 `MessageListenerContainer`가 `@KafkaHandler`가 붙은 모든 메소드에 적용한다. 

모두 실행되는 것은 아니라 payload 타입에 따라 적절하게 메소드를 실행해준다는 뜻이다. 

### `KafkaConsumer`

위 과정을 통해 `KafkaListenerContainer`가 생성되었다면 `KafkaListenerContainer`의 `start()` 메소드를 호출하여 `KafkaConsumer`를 생성한다.

<img src="assets/kafka-consumer.png" alt="img" style="zoom:80%;" />

`KafkaConsumer`가 생성되면 그림처럼 `ConsumerNetworkClient`, `SubscriptionState`, `ConsumerCoordinator`, `Fetcher`가 생성된다.
`HeartBeat` 스레드는 poll 메소드 호출 시 `ConsumerCoordinator`에 의해 생성되고 `KafkaConsumer`와는 별도의 스레드로 동작한다.

#### `ConsumerNetworkClient`

`ConsumerNetworkClient`는 `KafkaConsumer`의 모든 네트워크 통신을 담당한다.

`ConsumerNetworkClient`의 모든 요청은 비동기로 동작하며 `ConsumerNetworkClient`의 응답값은 `RequestFuture` 클래스로 확인한다.

#### `SubscriptionState`

`KafkaConsumer`는 다른 메시지 시스템과 달리 자신이 소비하는 토픽, 파티션, 오프셋 정보를 추적 및 관리한다. 

`SubscriptionState`가 토픽, 파티션, 오프셋 정보 관리를 담당하고 있다.

#### `ConsumerCoordinator`

`ConsumerCoordinator`는 컨슈머 리밸런스, 오프셋 초기화(일부), 오프셋 커밋을 담당한다.

`ConsumerCoordinator` 내부에는 `Heartbeat` 스레드가 존재한다. `Heartbeat` 스레드는 주기적으로 heartbeat를 `GroupCoordinator`에게 전송한다.

## 시퀀스 다이어그램

## 참조
- https://bistros.tistory.com/126
- https://bistros.tistory.com/127
- https://d2.naver.com/helloworld/0974525
- https://ojt90902.tistory.com/1092