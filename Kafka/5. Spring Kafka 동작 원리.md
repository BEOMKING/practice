카프카 컨슈머는 아래와 같이 구성되었다.

```java

@EnableKafka
@EnableConfigurationProperties(KafkaProperties.class)
@Configuration
@ConditionalOnProperty(name = "spring.kafka.consumer.enabled", havingValue = "true")
public class KafkaConsumerConfig {
    private final KafkaProperties kafkaProperties;

    public KafkaConsumerConfig(final KafkaProperties kafkaProperties) {
        this.kafkaProperties = kafkaProperties;
    }

    @Bean
    public KafkaListenerContainerFactory<ConcurrentMessageListenerContainer<String, Chat>> kafkaListenerContainerFactory() {
        final ConcurrentKafkaListenerContainerFactory<String, Chat> factory = new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory());
        factory.setBatchListener(true);
        factory.getContainerProperties().setAckMode(ContainerProperties.AckMode.MANUAL);

        return factory;
    }

    @Bean
    public ConsumerFactory<String, Chat> consumerFactory() {
        return new DefaultKafkaConsumerFactory<>(consumerConfig(), new StringDeserializer(), new JsonDeserializer<>(Chat.class));
    }

    @Bean
    public Map<String, Object> consumerConfig() {
        return Map.of(
                ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaProperties.getBootstrapServers(),
                ConsumerConfig.GROUP_ID_CONFIG, "chatGroupId",
                ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 200,
                ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "latest",
                ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false
        );
    }

}
```

```java

@Slf4j
@Service
public class ChatConsumer {
    private final ChatRepository chatRepository;

    public ChatConsumer(final ChatRepository chatRepository) {
        this.chatRepository = chatRepository;
    }

    @KafkaListener(id = "chatListener1", topics = "#{'${spring.kafka.topics.chat}'.split(',')}", containerFactory = "kafkaListenerContainerFactory", autoStartup = "${spring.kafka.consumer.enabled}")
    public void recordChat(final List<Chat> chat, final Acknowledgment ack) {
        log.info("Consumed size : {}", chat.size());
        chat.forEach(chatRepository::save);
        ack.acknowledge();
    }
}
```

이 코드들이 내부적으로 어떻게 동작하는지 하향식으로 살펴본다.

## `MessageListenerContainer`

Spring에서 메시지를 읽어오기 위해서는 Listener가 필요하다. `ConcurrentMessageListenerContainer` 클래스가 이 역할을 수행한다.

최상단의 `MessageListenerContainer`는 `KafkaMessageListenerContainer`, `ConcurrentMessageListenerContainer` 두 가지가 구현체로 제공된다.

- `KafkaMessageListenerContainer` 클래스
    - Java Consumer를 이용하여 Single-Thread 형태로 메시지를 읽어오는 방식
    - while (true)를 수행하면서 consumer.poll()을 통해 메시지를 읽어온다.

- `ConcurrentMessageListenerContainer` 클래스
    - Concurrency와 실제 Partition의 수에 따라 `KafaMessageListenerContainer`를 N개 생성한다.
```java

public class ConcurrentMessageListenerContainer<K, V> extends AbstractMessageListenerContainer<K, V> {
    private final List<KafkaMessageListenerContainer<K, V>> containers = new ArrayList<>();
    // 생략
```

따라서 여러 개의 Partition을 처리하기 위해서는 `ConcurrentMessageListenerContainer`를 사용하는 것이 더 낫다.

이런 ListenerContainer를 사용하는 것이 KafkaConsumer를 사용하는 것보다 풍부한 Ack 모드 지원, 메뉴얼 토픽 파티션 어사인, 오프셋 점프, 손쉬운 스레드 세이프 관리 등의 장점이 있다.

## `@KafkaListener`
위에서 언급한 `ConcurrentMessageListenerContainer`를 사용하기 위해서는 `@KafkaListener` 어노테이션을 사용해야 한다.

토픽의 메시지를 소비할 메소드에 어노테이션을 붙이면 `KafkaListenerContainerFactory`를 통해 `ConcurrentMessageListenerContainer`를 생성하고 `KafkaListenerEndpointRegistry`에 등록된다.

메소드에 `@KafkaListener` 어노테이션을 붙이면 각 메소드별로 `MessageListenerContainer`가 생성된다.

클래스에 정의된다면 하나의 `MessageListenerContainer`가 `@KafkaHandler`가 붙은 모든 메소드에 적용한다. 

모두 실행되는 것은 아니라 payload 타입에 따라 적절하게 메소드를 실행해준다는 뜻이다. 



### 참조
- https://bistros.tistory.com/126
- https://bistros.tistory.com/127
- https://d2.naver.com/helloworld/0974525
- https://ojt90902.tistory.com/1092